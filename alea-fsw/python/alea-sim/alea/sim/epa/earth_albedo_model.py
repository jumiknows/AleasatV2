from alea.sim.configuration import Configurable
from alea.sim.kernel.generic.abstract_model import AbstractModel
from alea.sim.kernel.kernel import AleasimKernel

import dataclasses # To automatically create dunder methods for a class
from pathlib import Path # For type hinting

import numpy as np
from numpy import ndarray

from alea.sim.math_lib.shapes import WGS84Earth

@dataclasses.dataclass
class EarthAlbedoConfig():
    
    f_sun : int = 1358 # in watts/m^2
    albedo_value : float = 0.3 # unitless

class EarthAlbedoModel(Configurable[EarthAlbedoConfig], AbstractModel):
    
    """
    Author: Tony Li

    Description: 
    This Earth Albedo Model implements a modified variation of the Earth Albedo 
    Model/Algorithm described by Thomas W. Flatley and Wendy A. Moore at NASA.

    Reference: 

    Thomas W. Flatley and Wendy A. Moore.

    "An Earth Albedo Model: A Mathematical Model for the Radiant 
    Energy Input to an Orbiting Spacecraft Due to the Diffuse Reflectance of Solar
    Radiation From the Earth Below"

    NASA, January 1994
    URL: https://ntrs.nasa.gov/api/citations/19940020024/downloads/19940020024.pdf

    """

    def __init__(
        self, 
        sim_kernel: AleasimKernel, 
        name: str = "earth_albedo_model",
        cfg: str | Path | dict | EarthAlbedoConfig = "albedo_model"):

        super().__init__(sim_kernel=sim_kernel, name=name)
        self._albedo = cfg.albedo_value
        self._f_sun = cfg.f_sun

        # Generate the Earth as a Spheroid
        self.earth = WGS84Earth()
        
    def _getAreaCurrent(
            self, 
            i_max           : float, 
            max_css_fov_deg : float,
            n_e_orbital     : ndarray, 
            sun_vector_eci  : ndarray, 
            n_css_body      : ndarray, 
            u_css_orbital   : ndarray
        ) -> tuple[float, float]:

        '''
        For the CSS that called the function, calculates the current from diffusely reflected incident sunlight on
        an infinitesimal area element at the position of the spacecraft.

        Parameters:
        - i_max (float)             : maximum current generated in CSS by direct sunlight, in amperes.

        - max_css_fov_deg (float)   : maximum field of view of the CSS that called the function, in degrees.

        - n_e_orbital (ndarray)     : unit vector normal to the area element from 
            which light reflects from. This vector is in orbital (LVLF) frame.

        - sun_vector_eci (ndarray)  : unit vector pointing from Earth to Sun. 
            This vector is in the ECI frame.

        - n_css_body (ndarray)      : unit vector normal to the CSS that called the function.
            This vector is in the body frame of the spacecraft.

        - u_css_orbital (ndarray)   : unit vector pointing from the spacecraft to the area element.
            This vector is in the orbital (LVLF) frame.

        
        Returns:
        - di (float)        : the current generated in the CSS by reflected radiance off an 
            infinitesimal area element, measured in amperes.

        - d_flux (float)    : the flux at the position of the spacecraft generated by reflected radiance
            off of an infinitesimal area element, measured in watts/m^2.
        '''

        # Convert all vectors to the same frame (arbitrarily chosen to be the orbital frame) before computing
        sun_vector_orbital = self.kernel.orbit_frame.transform_vector_from_frame(sun_vector_eci, self.kernel.eci_frame)
        n_css_orbital = self.kernel.orbit_frame.transform_vector_from_frame(n_css_body, self.kernel.body_frame)
        
        # Check if the current CSS can even see the area element.
        # This assumes that the n_css and u_css vectors are unit.
        angle_deg = float(np.degrees(np.arccos(np.dot(n_css_orbital, u_css_orbital))))
        if angle_deg > max_css_fov_deg:
            return 0.0, 0.0
        
        d_flux = (self._albedo / np.pi) * (self._f_sun) * (np.dot(n_e_orbital, sun_vector_orbital))
        di = (i_max / self._f_sun) * d_flux * (np.dot(n_css_orbital, u_css_orbital))

        return di, d_flux

    def getTotalCurrent(
        self, 
        i_max               : float, 
        max_css_fov_deg     : float, 
        sun_vector_eci      : ndarray, 
        n_css_body          : ndarray
        ) -> tuple[float, float]:
            
        '''
        For the CSS that called the function, calculates the total current due to diffusely
        reflected incident sunlight from all earth areas visible to the CSS.

        Parameters:
        - i_max (float)             : maximum current generated in CSS by direct sunlight, in amperes.

        - max_css_fov_deg (float)   : maximum field of view of the CSS that called the function, in degrees.
        
        - sun_vector_eci (ndarray)  : unit vector pointing from Earth to Sun. 
            This vector is in the ECI frame.

        - n_css_body (ndarray)      : unit vector normal to the CSS that called the function.
            This vector is in the body frame of the spacecraft.

        Returns:
        - reflectance_current (float)   : the total current generated in the CSS by reflected radiance 
            off Earth's visible surface, measured in amperes.

        - reflectance_flux (float)      : the total flux at the position of the spacecraft generated by
            reflected radiance off of Earth's visible surface, measured in watts/m^2.

        '''
        reflectance_current = 0
        reflectance_flux = 0

        # Currently we are using phi and theta steps of 10, we can change this to whatever we want
        x_meshcoords, y_meshcoords, z_meshcoords = self.earth.cartesian_surface_grid()

        for i in range(len(x_meshcoords)):
            for j in range(len(x_meshcoords[0])):
                
                # Calculate the normal vector to the area element
                n_e_ecef = np.array([x_meshcoords[i][j], y_meshcoords[i][j], z_meshcoords[i][j]])

                # Get the spacecraft's location in orbital frame
                # this is simply the frame transformation of the origin in the body frame
                spacecraft_coord_ecef = self.kernel.ecef_frame.transform_vector_from_frame(
                    np.array([0,0,0]), self.kernel.orbit_frame) 

                # Calculate the unit vector pointing from the spacecraft to the area element
                u_css_ecef = n_e_ecef - spacecraft_coord_ecef

                # calculate orbital versions of u_css and n_e to pass into _getAreaCurrent() format
                u_css_orbital = self.kernel.orbit_frame.transform_vector_from_frame(
                    u_css_ecef, self.kernel.ecef_frame
                )
                n_e_orbital = self.kernel.orbit_frame.transform_vector_from_frame(
                    n_e_ecef, self.kernel.ecef_frame
                )

                # Normalize those vectors because _getAreaCurrent()
                n_e_orbital = n_e_orbital / np.linalg.norm(n_e_orbital)
                u_css_orbital = u_css_orbital / np.linalg.norm(u_css_orbital)

                # Calculate the reflectance current generated by this particular area element
                di, d_flux = self._getAreaCurrent(i_max, 
                                            max_css_fov_deg, 
                                            n_e_orbital, 
                                            sun_vector_eci, 
                                            n_css_body, 
                                            u_css_orbital)
                
                reflectance_current += di
                reflectance_flux += d_flux

        return reflectance_current, reflectance_flux
    