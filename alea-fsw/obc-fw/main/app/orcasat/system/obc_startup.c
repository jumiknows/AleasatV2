/*
 * obc_startup.c
 *
 * This file contains our pre-main checks. For example, we can query the registers and determine
 * what kind of reset was asserted before the current run. This will be a good indicator of what's
 * going on when we get up into space. The code came from HALCoGen and using #defines in
 * sys_startup.c, disables existing code and inserts itself after the system performs self tests and
 * clears out the RAM.
 *
 *  Created on: Aug 27, 2017
 *      Author: Lana, Richard
 */

#include "obc_startup.h"
#include "can.h"
#include "reg_system.h"
#include "obc_utils.h"
#include "obc_flash.h"
#include "logger.h"

/* start_t
 *  - enumeration of the startup methods, used for indexing the startup type array
 */
typedef enum { DEFAULT_START, PORRST_START, DEBUG_START, SOFT_RESET_INTERNAL_START, SOFT_RESET_EXTERNAL_START, OSCFAIL_START, WATCHDOG_START, CPU_RESET_START } start_t;

typedef struct startup_data {
    start_t reset_src;
} startup_data_t;

startup_data_t start_data;

void startup_init(void) {
    start_data.reset_src = DEFAULT_START;
}

void print_startup_type(void) {
    /* Startup strings
     *  - note: must match order of start_t enum
     */
    //const char* startup_string[] = {"DEFAULT_START", "PORRST_START", "DEBUG_START", "SOFT_RESET_INTERNAL_START", "SOFT_RESET_EXTERNAL_START", "OSCFAIL_START", "WATCHDOG_START", "CPU_RESET_START"};

    LOG_START_TYPE__RESET_SRC(start_data.reset_src);
}

/* log_PBIST_fails
 *  - we can't easily save PBIST into a variable since RAM gets wiped out
 *  - so we keep PBIST fails in the CAN register since we're not otherwise using it
 *  - if any failures have been caught, log them
 *  - upon PBIST fail detect, reset once (logging each time)
 */
void log_PBIST_fails(void) {
    bool failure_detected           = false;
    volatile uint8_t pbist_complete = canREG1->IF1DATx[0U];
    volatile uint8_t pbist_failed   = canREG1->IF1DATx[1U];
    uint8_t i;

    for (i = 0U; i < 8U; i++) {
        bool bit_complete = (pbist_complete >> i) & 1U;
        bool bit_failed   = (pbist_failed >> i) & 1U;

        if (bit_complete && bit_failed) {
            /* TODO: IEC that PBIST failed */
            failure_detected = true;
        }
    }

    /* TODO: Set failure_detected to true to test reading flag from flash. Can we auto test this?
        failure_detected = true;
    */

    if (failure_detected) {
        bool was_reset = false;
        LOG_PBIST_STATUS__FAILED(pbist_failed);

        /* TODO: read was_reset from flag file
         *  was_reset = read from flag file
         */

        if (!was_reset) {
            /* TODO:
             *  - log that a reset had to occur
             *  - set was_reset = true in flag file
             */
            // TODO: restart_software();
        }
    } else {
        /* TODO: set was_reset flag = false in flag file so that it can be used next time */
        LOG_PBIST_STATUS__SUCCESS();
    }
}

/*  STARTUP CHECK
 *      - The first default chunk of sys_startup generated by halcogen, but changed so we can
 * recover the source of reset.
 */
void startup_check(void) {
    /* USER CODE END */

    /* Workaround for Errata CORTEXR4 66 */
    _errata_CORTEXR4_66_();

    /* Workaround for Errata CORTEXR4 57 */
    _errata_CORTEXR4_57_();

    /* Reset handler: the following instructions read from the system exception status register
     * to identify the cause of the CPU reset.
     */

    /* check for power-on reset condition */
    /*SAFETYMCUSW 139 S MR:13.7 <APPROVED> "Hardware status bit read check" */
    if ((SYS_EXCEPTION & POWERON_RESET) != 0U) {
        start_data.reset_src = PORRST_START;
        SYS_EXCEPTION        = 0xFFFFU; /* clear all reset status flags */
        /* continue with normal start-up sequence */
    }
    /*SAFETYMCUSW 139 S MR:13.7 <APPROVED> "Hardware status bit read check" */
    else if ((SYS_EXCEPTION & OSC_FAILURE_RESET) != 0U) {
        /* Reset caused due to oscillator failure.
        Add user code here to handle oscillator failure */

        start_data.reset_src = OSCFAIL_START;
    }
    /*SAFETYMCUSW 139 S MR:13.7 <APPROVED> "Hardware status bit read check" */
    else if ((SYS_EXCEPTION & WATCHDOG_RESET) != 0U) {
        /* Reset caused due
         *  1) windowed watchdog violation - Add user code here to handle watchdog violation.
         *  2) ICEPICK Reset - After loading code via CCS / System Reset through CCS
         */
        /* Check the WatchDog Status register */
        if (WATCHDOG_STATUS != 0U) {
            /* Add user code here to handle watchdog violation. */
            start_data.reset_src = WATCHDOG_START;

            /* Clear the Watchdog reset flag in Exception Status register */
            SYS_EXCEPTION = WATCHDOG_RESET;
        } else {
            /* Clear the ICEPICK reset flag in Exception Status register */
            SYS_EXCEPTION        = ICEPICK_RESET;
            start_data.reset_src = DEBUG_START;
        }
    }
    /*SAFETYMCUSW 139 S MR:13.7 <APPROVED> "Hardware status bit read check" */
    else if ((SYS_EXCEPTION & CPU_RESET) != 0U) {
        /* Reset caused due to CPU reset.
        CPU reset can be caused by CPU self-test completion, or
        by toggling the "CPU RESET" bit of the CPU Reset Control Register. */

        start_data.reset_src = CPU_RESET_START;

        /* clear all reset status flags */
        SYS_EXCEPTION = CPU_RESET;
    }
    /*SAFETYMCUSW 139 S MR:13.7 <APPROVED> "Hardware status bit read check" */
    else if ((SYS_EXCEPTION & SW_RESET) != 0U) {
        /* Reset caused due to software reset.
         */
        start_data.reset_src = SOFT_RESET_INTERNAL_START;
    } else {
        /* Reset caused by nRST being driven low externally.
        Add user code to handle external reset. */

        start_data.reset_src = SOFT_RESET_EXTERNAL_START;
    }

    /* Check if there were ESM group3 errors during power-up.
     * These could occur during eFuse auto-load or during reads from flash OTP
     * during power-up. Device operation is not reliable and not recommended
     * in this case.
     * An ESM group3 error only drives the nERROR pin low. An external circuit
     * that monitors the nERROR pin must take the appropriate action to ensure that
     * the system is placed in a safe state, as determined by the application.
     */
    if ((esmREG->SR1[2]) != 0U) {
        /* USER CODE BEGIN (24) */
        /* USER CODE END */
        /*SAFETYMCUSW 5 C MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif"
         * in the user codes above and below" */
        /*SAFETYMCUSW 26 S MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif"
         * in the user codes above and below" */
        /*SAFETYMCUSW 28 D MR:NA <APPROVED> "for(;;) can be removed by adding "# if 0" and "# endif"
         * in the user codes above and below" */
        for (;;) {
        } /* Wait */

        /* USER CODE BEGIN (25) */
        /* USER CODE END */
    }
}

/* Save PBIST Passed
 *  - in unused CAN register, save a flag indicating that PBIST passed
 */
void save_PBIST_passed(uint8_t test_num) {
    canREG1->IF1DATx[0U] = canREG1->IF1DATx[0U] | (uint8_t)(1U << test_num);
}

/* Save PBIST Passed
 *  - in unused CAN register, save a flag indicating that PBIST passed
 */
void save_PBIST_failed(uint8_t test_num) {
    canREG1->IF1DATx[1U] = canREG1->IF1DATx[1U] | (uint8_t)(1U << test_num);
}

void obc_startup_logs(void) {
    /* TODO:
     *  - log reason for reset (start_data.reset_src)
     */
}
