from typing import Iterator

from alea.common.data_field import data_field
from alea.common.data_field import data_field_impl

from alea.obcfw.util import spec_utils
import alea.obcfw.telem.data

class OBCTelemSpecError(Exception):
    def __init__(self, msg: str = None, spec: "OBCTelemSpec" = None):
        self._spec = spec
        if spec is None:
            super().__init__(msg)
        else:
            super().__init__(f"{self.__class__.__name__} on command: {spec.name} ({spec.id}). {msg}")

    @property
    def spec(self) -> "OBCTelemSpec":
        return self._spec

class OBCTelemDataFieldError(OBCTelemSpecError):
    def __init__(self, msg: str = None, data_field_error: data_field.DataFieldError = None, spec: "OBCTelemSpec" = None):
        self._data_field_error = data_field_error
        if data_field_error is None:
            super().__init__(msg, spec)
        else:
            super().__init__(str(data_field_error), spec)

    @property
    def data_field_error(self) -> data_field.DataFieldError:
        return self._data_field_error

class OBCTelemSpecEncodeError(OBCTelemDataFieldError):
    pass

class OBCTelemSpecDecodeError(OBCTelemDataFieldError):
    pass

class OBCTelemSpecNotFoundError(OBCTelemSpecError):
    pass

class OBCTelemSpec:
    """Specification for a single telemetry unit.

    Attributes:
        name (readonly): Name of the telem unit.
        id (readonly): ID of the telem unit.
        resp (readonly): Specification for the response generated by the telem unit.
                         If the command sends a response with raw data, pass `RAW_RESPONSE`.
                         If the command sends a response with fields, pass a list of `OBCTelemField` instances.
    """

    def __init__(self, name: str, id: int, priority: int, period: int, resp: data_field.DataFieldList):
        self._name = name
        self._id = id
        self._priority = priority
        self._period = period
        self._resp = resp

    @property
    def name(self) -> str:
        return self._name

    @property
    def id(self) -> int:
        return self._id

    @property
    def priority(self) -> int:
        return self._priority

    @property
    def period(self) -> int:
        return self._period

    @property
    def has_resp(self) -> bool:
        return self._resp is not None
 
    @property
    def resp(self) -> data_field.DataFieldList:
        return self._resp
 
class OBCTelemSpecs:
    """A set of telemetry specifications for telemetry units and their responses.
    """

    def __init__(self, specs: list[OBCTelemSpec]):
        self._specs = specs
        self._periods_dict = self._assignToPeriods()
        self._validate()
 
    def _validate(self):
        """Validates the specifications in this object.

        Raises:
            OBCTelemSpecError: If a duplicate ID exists in the list of specifications.
        """
        specs_by_id: dict[int, OBCTelemSpec] = {}

        for spec in self._specs:
            # Check if ID already used
            if spec.id in specs_by_id:
                raise OBCTelemSpecError(f"Duplicate ID ({spec.id}) for {specs_by_id[spec.id].name} and {spec.name}")

            specs_by_id[spec.id] = spec

        # Check if any collection period is <1s or if overflows the 32bit integer
        for period in self._periods_dict.keys():
            if period < 1 or period >= 4294967295:
                raise OBCTelemSpecError(f"Period of {key}s does not fall within the acceptable range.")

            if not isinstance(period, int):
                raise OBCTelemSpecError("All periods must be an integer")

    def _assignToPeriods(self) -> dict[int, list[OBCTelemSpec]]:
        """Populates a dictionary that has keys corresponding to collection periods. Value is a list of all telem ids
        that fall into that collection period, sorted in order of priority
        """

        periods: dict[int, list[OBCTelemSpec]] = {}

        for spec in self._specs:
            if spec.period not in periods:
                periods[spec.period] = [spec]
            else:
                periods[spec.period].append(spec)

        # Sort by priority
        for specs in periods.values():
            specs.sort(key=lambda x: x.priority)

        return periods
    
    @property
    def periods_dict(self) -> dict[int, list[OBCTelemSpec]]:
        """Dictionary of periods and respective units
        """
        return self._periods_dict

    @property
    def longest_collection_period(self) -> int:
        """Dictionary of periods and respective units
        """
        max = 0
        for period in self._periods_dict.keys():
            if period > max:
                max = period

        return max

    @property
    def max_id(self) -> int:
        """Largest ID any command has in this set of specs.
        """
        return max(map(lambda spec : spec.id, self._specs))

    @property
    def count(self) -> int:
        """Number of available command system specs
        """
        return len(self._specs)

    def get(self, name: str = None, id: int = None) -> OBCTelemSpec:
        """Retrieves a telem spec by name or by id.

        Either a name or an ID can be provided but not both.

        Args:
            name: The name of the spec to retrieve.
            id: The ID of the spec to retrieve.

        Raises:
            OBCTelemSpecNotFoundError: If there is no spec with the given name or ID.
            RuntimeError: If both a name and ID are provided

        Returns:
            The command system spec with the target name or ID.
        """

        if (name is not None) and (id is not None):
            raise RuntimeError("Cannot pass both name and id")

        if name is not None:
            name = name.upper()
            try:
                return next(spec for spec in self._specs if spec.name.upper() == name)
            except StopIteration:
                raise OBCTelemSpecNotFoundError(f"No command with name: {name}")

        if id is not None:
            try:
                return next(spec for spec in self._specs if spec.id == id)
            except StopIteration:
                raise OBCTelemSpecNotFoundError(f"No command with ID: {id}")

    def __iter__(self) -> Iterator[OBCTelemSpec]:
        return self._specs.__iter__()

    def __getitem__(self, val: int | slice) -> OBCTelemSpec | list[OBCTelemSpec]:
        return self._specs[val]

    def __str__(self) -> str:
        return "\n".join(map(str, self._specs))
 
    @classmethod
    def load(cls, dicts: list[dict] = None) -> "OBCTelemSpecs":
        """Creates an OBCTelemSpecs object loaded with data from either the JSON spec files
        included in this package (if dicts is None) or the dictionaries passed to this function.

        The structure of each dictionary should be as follows (represented as JSON):
        ```
        {
            "<command name>": {
                "id": <ID int>,
                "priority": <0,1,2 int>,
                "period": <int>,
                "resp": [
                    {"<field name>": "<field type>"},
                    ...
                ]
            },
            ...
        }
        ```

        Raises:
            OBCTelemSpecError: If a duplicate ID exists in the list of specifications.
            OBCTelemDataFieldError: If the resp specifications are invalid.

        Returns:
            An `OBCTelemSpecs` instance representing the aggregated set of telemetry specifications.
        """
        if dicts is None:
            dicts = spec_utils.load_json_resources(alea.obcfw.telem.data, "telem.json")

        specs = []

        for dict_data in dicts:
            for telem_name in dict_data:
                telem_unit = dict_data[telem_name]

                # Response
                resp_fields = []
                for resp_field in telem_unit["resp"]:
                    for resp_field_name in resp_field:
                        resp_field_type = resp_field[resp_field_name]
                        try:
                            resp_field = data_field_impl.DataFieldImpl.create_data_field(resp_field_name, resp_field_type)
                        except data_field.DataFieldError as e:
                            raise OBCTelemDataFieldError(data_field_error=e)
                        resp_fields.append(resp_field)

                if resp_fields == []:
                    resp = None
                else:
                    resp = data_field.DataFieldList(resp_fields)

                    if resp.has_variable_field:
                        raise OBCTelemDataFieldError("Telem does not support variable data fields")

                # Telem ID
                telem_id = telem_unit["id"]
                if isinstance(telem_id, str):
                    telem_id = int(telem_id, 0)

                # Priority
                telem_priority = telem_unit["priority"]
                if (not isinstance(telem_priority, int)):
                    raise OBCTelemDataFieldError()
                if (telem_priority < 0 or telem_priority > 2):
                    raise OBCTelemDataFieldError()

                # Period
                telem_period = telem_unit["period"]
                if (not isinstance(telem_period, int)):
                    raise OBCTelemDataFieldError()
                
                specs.append(OBCTelemSpec(telem_name, telem_id, telem_priority, telem_period, resp))

        return OBCTelemSpecs(specs)
