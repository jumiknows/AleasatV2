import numpy as np
import dataclasses
from pathlib import Path

from alea.sim.kernel.kernel import AleasimKernel
from alea.sim.configuration import Configurable
from alea.sim.kernel.time_cached import TimeCachedModel, time_cached_property
from alea.sim.kernel.kernel import SharedMemoryModelInterface
from alea.sim.kernel.scheduler import EventPriority
from alea.sim.kernel.generic.abstract_model import AbstractModel
from alea.sim.epa.orbit_dynamics import OrbitDynamicsModel

@dataclasses.dataclass
class SolarPanelConfig:
    inherent_degradation    : float
    mission_lifetime        : float
    degradation_per_year    : float
    cell_area               : float
    cells_per_panel         : int
    cell_efficiency         : float

    solar_flux              : float     = 1367.0
    update_freq_divider     : int       = 1 # By default, solar panel gen updates at the same frequency as attitude dynamics i.e. kernel.timestep

class SolarPanelModel(Configurable[SolarPanelConfig], TimeCachedModel, SharedMemoryModelInterface, AbstractModel):
    """
    Solar panel model
    based on https://digitalcommons.usu.edu/cgi/viewcontent.cgi?article=4336&context=smallsat
    also read solar_panels.cfg for more information on the specific params
    """
    
    def __init__(self, sim_kernel: AleasimKernel, name: str, panel_normal: np.ndarray, cfg: str | Path | dict | SolarPanelConfig = "solar_panel") -> None:
        super().__init__(name=name, sim_kernel=sim_kernel, cfg=cfg, cfg_cls=SolarPanelConfig)
        self._panel_normal = panel_normal
        self.configure()

    # ==============================================================================
    # Configuration
    # ==============================================================================
        
    def configure(self):
        cfg = self.cfg
        # Constants
        self._area_panel = cfg.cell_area * cfg.cells_per_panel # Area of the solar panel in mÂ²

        #calculate degradation factor (multiple inherant and lifetime degradation)
        self._degradation_factor  =self.cfg.inherent_degradation * (1-self.cfg.degradation_per_year)**self.cfg.mission_lifetime
        
        self.logger.info(f'configured solar panel {self.name} with normal {self._panel_normal}')
        
        self._solar_power_gen = 0.0
        self._energy_gen_total = 0.0

        self._elem_names = [ 'pwr_gen', 'energy_gen_total']

    @property
    def update_period(self) -> float:
        return self.odyn.update_period * self.cfg.update_freq_divider

    # ==============================================================================
    # Kernel Events
    # ==============================================================================

    def connect(self):
        self.odyn: OrbitDynamicsModel = self.kernel.get_model(OrbitDynamicsModel)

    def start(self):
        self.kernel.schedule_event(0, EventPriority.POWER_EVENT_SOLAR, self.update, self.update_period)

    # ==============================================================================
    # Simulation Variables
    # ==============================================================================

    @time_cached_property
    def _solar_power_gen(self) -> float:
        return self._calculate_solar_power_gen()

    @property
    def solar_power_gen(self) -> np.ndarray:
        return self._solar_power_gen

    # ==============================================================================
    # State Update
    # ==============================================================================

    def _calculate_solar_power_gen(self) -> float:
        if self.odyn.is_sunlit:
            # Calculate the sun vector in the ECI frame
            sun_vec_eci = self.odyn.sun_vector_norm
            
            # Convert the sun vector from ECI to the body frame
            sun_vec_body_norm = self.kernel.body_frame.transform_vector_from_frame(sun_vec_eci, self.kernel.eci_frame)
                
            # Calculate the cosine of the angle between the sun vector and the panel normal
            cos_angle = np.dot(sun_vec_body_norm, self._panel_normal)
            cos_angle = np.clip(cos_angle, 0.0, 1.0)  # Ensure cos_angle is in valid range (0 to 1)
                
            # Calculate power generated by the panel
            solar_power_gen = self.cfg.solar_flux * cos_angle * self._area_panel * self.cfg.cell_efficiency * self._degradation_factor
        else:
            solar_power_gen = 0.0

        return solar_power_gen
    
    def update(self):
        """call at update rate of orbital dynamics"""
        self.invalidate_cache(self.kernel.time_n)

        solar_power_gen = self._calculate_solar_power_gen()

        self._solar_power_gen = solar_power_gen
        self._energy_gen_total += solar_power_gen * self.update_period

        self.save_chunk_to_memory([self._solar_power_gen, self._energy_gen_total])

    @property
    def saved_state_element_names(self):
        return [ 'pwr_gen', 'energy_gen_total']

    @property
    def saved_state_size(self):
        return len(self.saved_state_element_names)